## FileSystems

![image103](https://github.com/user-attachments/assets/6e7c3f33-923c-402b-9399-6f5d1484e62f)


**The Big Picture**

•User applications access files using a standard API

•This does not change no matter what storage media, partition, or used file system type

•The used API results in a system call towards the kernel (generated by the C-Library)

•The system call is received by the VFS (Virtual File System) subsystem of the Linux Kernel

•This subsystem provides a unified access to the file via the concepts of nodes and dentries (A previous lecture covered VFS in details)

•VFS then communicate with the used FileSystem that contain this file

•The filesystem in turn Communicate with the device driver for the storage media using the block abstraction

•The device driver is responsible for interfacing with the storage hardware device


**Linux Extended FileSystems ext2**

•The ext2 used to be the most popular filesystem for Linux distributions running on a hard disk

•It uses block sizes of 1024, 2048, or 4096 Bytes

•Large values waste disk space if we have a lot of small files

•Small values increase overhead for metadata to point to the different blocks in the case of large files

•A problem with the ext2 was the risk of filesystem corruption due to unexpected reboots or power failures

•A planned reboot will unmount all filesystems before the system is shutdown

•This guarantees that the shutdown does not happen in the middle of a write operation

•However, in case of a sudden power failure or a system crash, the filesystem will not be unmounted, and we may run into a corruption of the data in the fileSystem (some of the data is written without updating the filesystem metadata)

•The solution for this problem is “Journaling”


**Journaling**

•The filesystem that support journaling will have a special file “The Journal File”

•Every time there is a modification to the filesystem (a write operation), this change is tracked first in the journal file then committed to the actual file in the filesystem

•This way, we will have a journaling points that we can revert to in case of a corruption (mismatch between filesystem contents and its meta-data)

•Upon a boot after a sudden shutdown/reboot, the journal file is tracked, and compared to the contents of the filesystem

•Changes in the journal may be applied or removed to maintain data consistency

•Most newer filesystems support Journaling to maintain the filesystem contents data integrity


**Linux Extended FileSystems ext3**

•The ext3 filesystem is an extension to the ext2 filesystem to support Journalling

•It is both forward and backword compatible with ext2 (we can convert ext2 filesystem to ext3 and vice versa)

•In ext2 when the system shuts down abruptly, the next boot takes long time, because a consistency check is run on the filesystem

•In ext3, no consistency check is needed, the journaling file is checked to verify changes, which is a much faster process

**Linux Extended FileSystems ext4**

•The ext4 filesystem is an extension to the ext3 filesystem

•Currently, it is the default filesystem for Linux

•It also supports journaling

•It removes some of the limitations of ext3,


•The ext4 filesystem can support filesystem size of more than the 16 terabyte which is the limit for ext3

•The ext4 filesystem can support file sizes of up to 1 Terabyte


**Cram FileSystem cramfs**

•This filesystem objective is to compress a filesystem into a small ROM

•It is a read-only filesystem

•It supports compression of the data in the filesystem

•Useful for small embedded systems to store read only data in a small ROM or flash


•Ideal for boot ROMs


**Memory Hosted FileSystems ramfs**

•A filesystem that lives in the system memory (RAM)

•This provides high access speed, but it is volatile (erased at reboot time or at shutdown)

•It is different from RamDisks that it can grow and shrink based on the need

**Memory Hosted FileSystems tmpfs**

•Like ramfs, everything is stored in system volatile memory (RAM)

•Accordingly, contents of this filesystem are lost on power failure or reboot

•Different from the ramfs in that it can not grow dynamically

•It can also use the swap while the ramfs can not

•Normally mount to /tmp

**Network FileSystem NFS**

•This filesystem will exist on a remote machine and will be accessed through the network

•Useful for sharing folders in the network

•A central NFS server will contain the filesystem data

•All machines that need to have access to the data will need to contain a NFS Client

•Machines with NFS Clients will need to mount the NFS filesystem (Map to the network drive)

**Virtual FileSystems procfs & sysfs**

•Those filesystems are not stored in any storage device, but they are managed by the kernel

•Reading from a file in this filesystem results in a query to the kernel

•Writing to a file results in sending some info to the kernel


**Show FileSystem Disk Space Usage (df Comand)**

`$ df`

`$ df -i (Show FileSystem inode Usage)`


**Show Process Disk Usage (du Command)**

`$ du <device>`

•This command shows the disk usage per process for the disk specified by the device filename

`$ du /dev/sda1`















