## FileSystems

![image103](https://github.com/user-attachments/assets/6e7c3f33-923c-402b-9399-6f5d1484e62f)


**The Big Picture**

•User applications access files using a standard API

•This does not change no matter what storage media, partition, or used file system type

•The used API results in a system call towards the kernel (generated by the C-Library)

•The system call is received by the VFS (Virtual File System) subsystem of the Linux Kernel

•This subsystem provides a unified access to the file via the concepts of nodes and dentries (A previous lecture covered VFS in details)

•VFS then communicate with the used FileSystem that contain this file

•The filesystem in turn Communicate with the device driver for the storage media using the block abstraction

•The device driver is responsible for interfacing with the storage hardware device


**Linux Extended FileSystems ext2**

•The ext2 used to be the most popular filesystem for Linux distributions running on a hard disk

•It uses block sizes of 1024, 2048, or 4096 Bytes

•Large values waste disk space if we have a lot of small files

•Small values increase overhead for metadata to point to the different blocks in the case of large files

•A problem with the ext2 was the risk of filesystem corruption due to unexpected reboots or power failures

•A planned reboot will unmount all filesystems before the system is shutdown

•This guarantees that the shutdown does not happen in the middle of a write operation

•However, in case of a sudden power failure or a system crash, the filesystem will not be unmounted, and we may run into a corruption of the data in the fileSystem (some of the data is written without updating the filesystem metadata)

•The solution for this problem is “Journaling”


**Journaling**

•The filesystem that support journaling will have a special file “The Journal File”

•Every time there is a modification to the filesystem (a write operation), this change is tracked first in the journal file then committed to the actual file in the filesystem

•This way, we will have a journaling points that we can revert to in case of a corruption (mismatch between filesystem contents and its meta-data)

•Upon a boot after a sudden shutdown/reboot, the journal file is tracked, and compared to the contents of the filesystem

•Changes in the journal may be applied or removed to maintain data consistency

•Most newer filesystems support Journaling to maintain the filesystem contents data integrity


**Linux Extended FileSystems ext3**

•The ext3 filesystem is an extension to the ext2 filesystem to support Journalling

•It is both forward and backword compatible with ext2 (we can convert ext2 filesystem to ext3 and vice versa)

•In ext2 when the system shuts down abruptly, the next boot takes long time, because a consistency check is run on the filesystem

•In ext3, no consistency check is needed, the journaling file is checked to verify changes, which is a much faster process

**Linux Extended FileSystems ext4**

•The ext4 filesystem is an extension to the ext3 filesystem

•Currently, it is the default filesystem for Linux

•It also supports journaling

•It removes some of the limitations of ext3,


•The ext4 filesystem can support filesystem size of more than the 16 terabyte which is the limit for ext3

•The ext4 filesystem can support file sizes of up to 1 Terabyte


**Cram FileSystem cramfs**

•This filesystem objective is to compress a filesystem into a small ROM

•It is a read-only filesystem

•It supports compression of the data in the filesystem

•Useful for small embedded systems to store read only data in a small ROM or flash


•Ideal for boot ROMs


**Memory Hosted FileSystems ramfs**

•A filesystem that lives in the system memory (RAM)

•This provides high access speed, but it is volatile (erased at reboot time or at shutdown)

•It is different from RamDisks that it can grow and shrink based on the need

**Memory Hosted FileSystems tmpfs**

•Like ramfs, everything is stored in system volatile memory (RAM)

•Accordingly, contents of this filesystem are lost on power failure or reboot

•Different from the ramfs in that it can not grow dynamically

•It can also use the swap while the ramfs can not

•Normally mount to /tmp

**Network FileSystem NFS**

•This filesystem will exist on a remote machine and will be accessed through the network

•Useful for sharing folders in the network

•A central NFS server will contain the filesystem data

•All machines that need to have access to the data will need to contain a NFS Client

•Machines with NFS Clients will need to mount the NFS filesystem (Map to the network drive)

**Virtual FileSystems procfs & sysfs**

•Those filesystems are not stored in any storage device, but they are managed by the kernel

•Reading from a file in this filesystem results in a query to the kernel

•Writing to a file results in sending some info to the kernel


**Show FileSystem Disk Space Usage (df Comand)**

`$ df`

`$ df -i (Show FileSystem inode Usage)`


**Show Process Disk Usage (du Command)**

`$ du <device>`

•This command shows the disk usage per process for the disk specified by the device filename

`$ du /dev/sda1`

**A Virtual FileSystem**


•A virtual filesystem is a filesystem that resides in memory and does not have physical files stored on some storage device

•Instead, it is just a way to send information between the user application and the kernel in the form of reading a file or writing to a file

•Examples of virtual filesystems are

•The procfs filesystem which is mounted in `/proc`

•The sysfs filesystem which is ususally mounted in  `/sys`

•When we write to a virtual filesystem file (as in /proc or /sys), we are sending information to the kernel for processing, and not storing data in a file

•When we are reading from a file in a virtual filesystem, we are actually querying the kernel, and causing some processing with some output, and not just reading from a file

•That is why, when we list files in a virtual filesystem, we normally find the timestamp showing the current time, and the file size maybe zero although we get data when we perform a read (through cat command for example)

•The `procfs and sysfs` filesystems are one way to learn a lot of information about the kernel by user space applications

•Most files in /proc are read only but some are writable (specially in /proc/sys/ )

•There are more files that are writable in /sys


•There are a lot of information that you can read from the /proc and /sys

•Information about processes, memory, interrupts, filesystems, hardware devices, network, and much more

•The initial role for /proc was to carry information about the processes, but it ended up with much more information

•The initial role for /sys was to carry information about the system devices and hardware buses but it also ended up with much more info

**Process List**

•The /proc contains a directory for each process running on the system

•Directories for processes are named with the process pid

•For example the init process will be represented by /proc/1

**/proc/cpuinfo**

•This file will carry the information about the processor cores in the machine

•It will show a list of all the processor cores with their attributes

•Core number

•Processor name, family, and model name

•Cache Size

•Does it have a FPU

•Processor Speed in MHz


**/proc/interrupts**

•This file will report information on the processor interrupts

•It will have a table for interrupts for all the cores in the system to show the number of interrupts for every interrupt line on each processor, and how many times this interrupt happened

•It will also show which devices are servicing these interrupts


**/proc/cmdline**

•This file shows the command line arguments that where passed to the kernel at its startup

•It will state things like

•Location of the root file system

•Where does the kernel send its messages (the different consoles)

•Should the kernel be “quiet” which means, it will not send its output to a console

•Location of the boot image for the kernel

**/proc/kcore**

•This file represents all the physical memory of the system

•Size of this file is same as the physical memory + 4 bytes


•Don’t try to list the file content since it is huge and will probably hang your system

•It can be used with debugger to analyze memory issues during development


**/sys**

•The sysfs is similar to the procfs from the perspective that it is a virtual filesystem, and reading/writing to its files trigger functionality in the kernel

•However, it comes with some differences,

•It mainly targets the description of attributes of system devices and hardware (both configuration and statistics)

•Its output/input is formatted to be used by a program, and hence it is not very human readable in some cases

•Each file represents one value (whether input or output)

•It does not have files that carry tables of information, or a list of parameters.

•If you need to show 4 counter statistics, then you will have 4 readable files in /sys (each file will contain a single counter value)

•If you need to configure two attributes of a device, you will need 2 writable files in /sys




